//go assigner.TimeToIdle(elev)
	
/* 	el:=make([]Elevator,2)					// HALLUP HALLDWN  CAB
	el[0]=Elevator{Floor:2,Requests:[4][3]bool{{false, true, false}, //FLOOR 4
											   {false, false, true}, //FLOOR 3
											   {true, true, false}, //FLOOR 2
										       {false, false, true}, //FLOOR 1
											},
					PrevDirection:UP}
	el[1]=Elevator{Floor:3,Requests:[4][3]bool{{false, false, false},
											   {false, true, false},
											   {true, true, false},
										       {false, false, false},
											}}
	fmt.Println(assigner.ChooseElevator(el,Order{0,1}))
	fmt.Println("Time until pickup for el[0]: ",fsm.TimeUntilPickup(el[0],Order{0,1}))
	fmt.Println("Time until pickup for el[1]: ",fsm.TimeUntilPickup(el[1],Order{0,1})) */

	/* for {
		if elev.Floor!=-1 {
			fmt.Println("Time to idle: ",assigner.TimeToIdle(elev))
		}
		time.Sleep(time.Second)
		select {
		case msg := <-MsgChan:
			// Process and print received message
			fmt.Printf("Message received: ID = %d, Heartbeat = %s\n", msg.ID, msg.Heartbeat)
	} */
	//Primary backup protocol
	/*go backup(listens to bcast from primary) */

	/* //Blocking select
	select {
		/* 
		case primary dead
			if next in queue:
				go primary
		}*/